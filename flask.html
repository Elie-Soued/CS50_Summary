<!DOCTYPE html>

<html lang="en">
  <head>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
      crossorigin="anonymous"
    ></script>
    <script src="navbar.js" type="module"></script>
    <script src="utils.js" type="module"></script>
    <link href="styles.css" rel="stylesheet" />
    <link href="/images/flaskFavicon.png" rel="icon" type="image/png" />
    <title>Flask</title>
  </head>
  <body class="d-flex flex-column align-items-center">
    <header class="d-flex flex-column justify-content-center w-75 h-auto">
      <nav-bar-50></nav-bar-50>
      <img src="/images/FlaskThumbnail.jpg" class="image_top" />
    </header>
    <main class="image_top">
      <section class="image_top">
        <p>
          In week 9, we discovered a Python framework called Flask.<br>
While taking the course, something didn't seem right to me.<br>
I couldn't understand why we were working with HTML on the server.<br>
Since I started learning to program, I had always used a frontend application to build the user interface and a separate backend application to connect requests from the frontend to the database.<br>
I kept wondering, "Why is the UI being generated on the server?"<br>
This confusion resulted from my previous exposure being limited to Client Side Rendering development (CSR) and pushed me to explore the difference between those 2 approaches.<br>


<h4>Client Side versus Server Side Rendering</h4> 
<br>

<b>Client Side Rendering:</b> We typically use a separate application to build the frontend.<br>
Data exchanged between the frontend and backend is in JSON format. <br>
For example, if I send a request to the backend to list all people matching specific criteria, the backend will return JSON data (perhaps an array of objects).
My frontend then processes this JSON and builds the UI in the browser using the frontend application's mechanisms.<br>
<br>

<b>Server Side Rendering:</b> We typically have a single application handling both frontend and backend. The frontend is created on the server and served directly to the browser.<br>
Traditional SSR (PHP, Ruby on Rails, etc.) renders static content, meaning if you want to update something on the page, you need to send a request to the server and receive a completely new page.<br>
Modern SSR (Next.js, Nuxt.js) can update parts of the page without rendering the whole page again. They combine characteristics of both SSR and CSR. <br>
It's SSR because the initial user interface is created on the server, but once loaded in the browser, it behaves like a CSR application.<br>
<br>
<b>To summarize:</b><br>
CSR               = JSON comes from the server → The browser builds the UI<br>
SSR (Traditional) = HTML comes from the server → The server builds the UI<br>
SSR (Modern)      = Application is built on the server and sent to the browser; once in the browser, the application sends and receives JSON to and from the server.<br>



Another interesting topic and a fundamental we saw in this week is user authorization.<br>
<br>

<h4>What is user authorization?</h4>

After a user successfully authenticates by providing the correct username and password, authorization is a mechanism that allows a user to access the different services of an application without having to authenticate anymore.<br>
Authorization is like getting a stamp on your wrist after being accepted in a club, to be able to get back in faster.<br>
There are 2 kinds of authorization : sessions based and token based authorizations.<br>

<b>Sessions</b><br>
In sessions, the session data is stored on the server and a session ID is sent to the client and stored in a cookie.<br>
Sessions are stateful meaning the client is coupled to a specific server.<br>
In distributed systems where the application is running on multiple servers, all the server needs access to the same session data which adds latency as each server needs to make a request to the session store.<br>
Sessions offer a more flexible way to invalidate the access to the server. 

<b>Tokens</b><br>
A token is sent to the client containing all necessary information for authorization. The token is sent with every request and uses asymetric keys.<br>
Tokens are stateless meaning the client is decoupled from the server which makes it a better choice for distributed systems. <br>

        </p>

        <div class="image_holder">
          <img src="/images/authorization.png" class="small_image" />
        </div>
      </section>
    </main>
    <footer>
      <p>
We almost reached the end of our journey but there is one more <a href="/theend.html">topic</a> I would like to share with you.
      </p>
    </footer>

  </body>
</html>
